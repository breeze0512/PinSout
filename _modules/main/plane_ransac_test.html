

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>main.plane_ransac_test &mdash; PinSout 1.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> PinSout
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../main.html">main package</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">PinSout</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>main.plane_ransac_test</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for main.plane_ransac_test</h1><div class="highlight"><pre>
<span></span><span class="c1"># import numpy as np</span>
<span class="c1"># import pcl</span>
<span class="c1"># import random</span>
<span class="c1"># import pcl.pcl_visualization</span>
<span class="c1"># import math</span>
<span class="c1"># from sympy import Symbol, solve, Eq</span>
<span class="c1"># import matplotlib.pyplot as plt</span>
<span class="c1"># import Point_sort as ps</span>
<span class="c1"># import time</span>
<span class="c1"># import ply2obj as po</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">plane_ransac_test.py</span>
<span class="sd">====================================</span>
<span class="sd">The core module of my example project</span>
<span class="sd">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="clustering"><a class="viewcode-back" href="../../main.plane_ransac_test.html#main.plane_ransac_test.clustering">[docs]</a><span class="k">def</span> <span class="nf">clustering</span><span class="p">(</span><span class="n">cloud</span><span class="p">,</span> <span class="n">vg_size</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">min_cluster_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Clustering the orginal point cloud data</span>

<span class="sd">        The voxelization of the original data for the downsampling.</span>
<span class="sd">        Extract clustered data from the voxelization data.</span>
<span class="sd">    </span>
<span class="sd">   </span>
<span class="sd">    :param pcl.PointCloud pcloud: Original point cloud data</span>
<span class="sd">    :param float vg_size: The voxel size to be voxelized</span>
<span class="sd">    :param float tolerance: Cluster tolerance variable</span>
<span class="sd">    :param int min_cluster_size: Minimum number of points in clustered data</span>
<span class="sd">   </span>
<span class="sd">    :returns: list cluster_list: List of the clustered cloud point data </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#     voxelization using voxel_gird_filter() - downsampling</span>
    <span class="c1"># original points = 205620 -&gt; after 24030</span>
    <span class="c1">#    :param int cloud: Original point cloud data</span>
    <span class="c1">#     :param int vg_size: The voxel size to be voxelized</span>
    <span class="c1">#     :param int tolerance: Cluster tolerance variable</span>
    <span class="c1">#     :param int min_cluster_size: Minimum number of points in clustered data</span>

    <span class="c1">#     :returns int: a + b에 대한 결과</span>
<span class="c1">#  Args:</span>
<span class="c1">#             cloud: Original point cloud data</span>
<span class="c1">#             vg_size: The voxel size to be voxelized</span>
<span class="c1">#             tolerance: Cluster tolerance variable</span>
<span class="c1">#             min_cluster_size: Minimum number of points in clustered data</span>

<span class="c1">#         Returns:</span>
<span class="c1">#             cluster_list: List of the clustered cloud point data</span>
<span class="c1">#     voxelization using voxel_gird_filter() - downsampling</span>
<span class="c1">#     original points = 205620 -&gt; after 24030</span>


    <span class="n">cluster_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">cloud_value</span> <span class="o">=</span> <span class="n">cloud</span>
    <span class="n">vg</span> <span class="o">=</span> <span class="n">cloud</span><span class="o">.</span><span class="n">make_voxel_grid_filter</span><span class="p">()</span>
    <span class="n">vg</span><span class="o">.</span><span class="n">set_leaf_size</span><span class="p">(</span><span class="n">vg_size</span><span class="p">,</span> <span class="n">vg_size</span><span class="p">,</span> <span class="n">vg_size</span><span class="p">)</span>
    <span class="n">cloud_filtered</span> <span class="o">=</span> <span class="n">vg</span><span class="o">.</span><span class="n">filter</span><span class="p">()</span>

    <span class="n">tree</span> <span class="o">=</span> <span class="n">cloud_filtered</span><span class="o">.</span><span class="n">make_kdtree</span><span class="p">()</span>
    <span class="n">ec</span> <span class="o">=</span> <span class="n">cloud_filtered</span><span class="o">.</span><span class="n">make_EuclideanClusterExtraction</span><span class="p">()</span>
    <span class="n">ec</span><span class="o">.</span><span class="n">set_ClusterTolerance</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span> <span class="c1"># 0.5 = 50cm</span>
    <span class="n">ec</span><span class="o">.</span><span class="n">set_MinClusterSize</span><span class="p">(</span><span class="n">min_cluster_size</span><span class="p">)</span> <span class="c1">#  impose that the clusters found must have at least</span>
    <span class="n">ec</span><span class="o">.</span><span class="n">set_MaxClusterSize</span><span class="p">(</span><span class="n">cloud_value</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="c1">#  impose that the clusters found must have at Maximum</span>
    <span class="n">ec</span><span class="o">.</span><span class="n">set_SearchMethod</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>


    <span class="n">cluster_indices</span> <span class="o">=</span> <span class="n">ec</span><span class="o">.</span><span class="n">Extract</span><span class="p">()</span> <span class="c1"># return index number that is included in the result of clustering</span>

    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">):</span>

        <span class="n">cloud_cluster</span> <span class="o">=</span> <span class="n">pcl</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">()</span>

        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>


        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">indice</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>

            <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cloud_filtered</span><span class="p">[</span><span class="n">indice</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cloud_filtered</span><span class="p">[</span><span class="n">indice</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cloud_filtered</span><span class="p">[</span><span class="n">indice</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">cloud_cluster</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">cluster_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cloud_cluster</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>

        <span class="k">return</span> <span class="n">cluster_list</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cluster_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cloud</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cluster_list</span></div>



<span class="c1"># def do_passthrough_filter( point_cloud, name_axis=&#39;z&#39;):</span>
<span class="c1">#</span>
<span class="c1">#     # Create a passthrough filter that removes points outside of the range 0 to 1.5 in the Z axis.</span>
<span class="c1">#     pass_filter = point_cloud.make_passthrough_filter()</span>
<span class="c1">#     pass_filter.set_filter_field_name(name_axis)</span>
<span class="c1">#</span>
<span class="c1">#     return pass_filter.filter()</span>

<div class="viewcode-block" id="do_plane_ransac"><a class="viewcode-back" href="../../main.plane_ransac_test.html#main.plane_ransac_test.do_plane_ransac">[docs]</a><span class="k">def</span> <span class="nf">do_plane_ransac</span><span class="p">(</span><span class="n">cloud</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Finding the plane from point cloud data</span>

<span class="sd">        Calculate the surface normals for each point by fitting a plane to the nearest.</span>

<span class="sd">   </span>
<span class="sd">    :param pcl.PointCloud cloud: Clustered point cloud data</span>

<span class="sd">    :returns: list inliers: Pointcloud data extracted by plane</span>
<span class="sd">    :returns: list outliers: Pointcloud data that is not extracted by plane</span>
<span class="sd">    :returns: list coefficients: Coefficient data of plane equation(a, b, c, d)</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="c1"># Calculate the surface normals for each point by fitting a plane to the nearest</span>
    <span class="c1"># 50 neighbours to the candidate point.</span>

    <span class="n">segmenter</span> <span class="o">=</span> <span class="n">cloud</span><span class="o">.</span><span class="n">make_segmenter_normals</span><span class="p">(</span><span class="n">ksearch</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">segmenter</span><span class="o">.</span><span class="n">set_model_type</span><span class="p">(</span><span class="n">pcl</span><span class="o">.</span><span class="n">SACMODEL_NORMAL_PLANE</span><span class="p">)</span> <span class="c1"># Fit a plane to the points.</span>
    <span class="n">segmenter</span><span class="o">.</span><span class="n">set_optimize_coefficients</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Do a little bit more optimisation once the plane has been fitted.</span>
    <span class="n">segmenter</span><span class="o">.</span><span class="n">set_normal_distance_weight</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>
    <span class="n">segmenter</span><span class="o">.</span><span class="n">set_method_type</span><span class="p">(</span><span class="n">pcl</span><span class="o">.</span><span class="n">SAC_RANSAC</span><span class="p">)</span>  <span class="c1"># Use RANSAC for the sample consensus algorithm.</span>
    <span class="n">segmenter</span><span class="o">.</span><span class="n">set_max_iterations</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>  <span class="c1"># Number of iterations for the RANSAC algorithm.</span>
    <span class="n">segmenter</span><span class="o">.</span><span class="n">set_distance_threshold</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span> <span class="c1"># The max distance from the fitted model a point can be for it to be an inlier.</span>

    <span class="n">inlier_indices</span><span class="p">,</span> <span class="n">coefficients</span> <span class="o">=</span> <span class="n">segmenter</span><span class="o">.</span><span class="n">segment</span><span class="p">()</span> <span class="c1"># Returns all the points that fit the model, and the parameters of the model.</span>

    <span class="c1"># Save all the inliers as a point cloud. This forms the table which the mug sits on.</span>
    <span class="n">inliers</span> <span class="o">=</span> <span class="n">cloud</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">inlier_indices</span><span class="p">,</span> <span class="n">negative</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Save all the outliers as a point cloud.</span>
    <span class="n">outliers</span> <span class="o">=</span> <span class="n">cloud</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">inlier_indices</span><span class="p">,</span> <span class="n">negative</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">inliers</span><span class="p">,</span> <span class="n">outliers</span><span class="p">,</span> <span class="n">coefficients</span></div>



<div class="viewcode-block" id="check_distance_plane"><a class="viewcode-back" href="../../main.plane_ransac_test.html#main.plane_ransac_test.check_distance_plane">[docs]</a><span class="k">def</span> <span class="nf">check_distance_plane</span><span class="p">(</span><span class="n">point_cloud</span><span class="p">,</span> <span class="n">coeff</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checking the distance between point and plane</span>

<span class="sd">    Find the number of points where the distance between the planes is 0.05 or less</span>
<span class="sd">    and calculate the percentage.</span>

<span class="sd">    </span>
<span class="sd">    :param pcl.PointCloud point_cloud: Pointcloud data extracted by plane</span>
<span class="sd">    :param list coeff: plane: Coefficient data of plane equation(a, b, c, d)</span>

<span class="sd">    :returns: float distance_rate: Percentage of points with a distance of 0.05 or less</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># checking the rate between point cloud and plane information</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">coeff</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">coeff</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">point_cloud</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">point_distance</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span>
            <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">z</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">point_distance</span> <span class="o">&lt;=</span> <span class="mf">0.1</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">distance_rate</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">distance_rate</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">distance_rate</span></div>

<div class="viewcode-block" id="plane_cluster"><a class="viewcode-back" href="../../main.plane_ransac_test.html#main.plane_ransac_test.plane_cluster">[docs]</a><span class="k">def</span> <span class="nf">plane_cluster</span><span class="p">(</span><span class="n">cloud_data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Clustering the exported plane data</span>

<span class="sd">        Finding clustered points in the data extracted as planes.</span>

<span class="sd">    :param pcl.PointCloud cloud_data: Pointcloud data extracted by plane</span>

<span class="sd">    :returns: list new_cloud_data: Clustered PointCloud data list</span>
<span class="sd">    :returns: list normal_vector: Plane coefficient list of clustered PointCloud data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">max_size</span> <span class="o">=</span> <span class="n">cloud_data</span><span class="o">.</span><span class="n">size</span>
    <span class="n">min_size</span> <span class="o">=</span> <span class="mi">200</span>
    <span class="n">new_cloud_data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">normal_vector</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">outliers_data</span> <span class="o">=</span> <span class="n">pcl</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">()</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">cloud_data</span><span class="o">.</span><span class="n">make_kdtree</span><span class="p">()</span>
    <span class="n">segment</span> <span class="o">=</span> <span class="n">cloud_data</span><span class="o">.</span><span class="n">make_EuclideanClusterExtraction</span><span class="p">()</span>
    <span class="n">segment</span><span class="o">.</span><span class="n">set_ClusterTolerance</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">segment</span><span class="o">.</span><span class="n">set_MinClusterSize</span><span class="p">(</span><span class="n">min_size</span><span class="p">)</span>
    <span class="n">segment</span><span class="o">.</span><span class="n">set_MaxClusterSize</span><span class="p">(</span><span class="n">max_size</span><span class="p">)</span>
    <span class="n">segment</span><span class="o">.</span><span class="n">set_SearchMethod</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="n">cluster_indices</span> <span class="o">=</span> <span class="n">segment</span><span class="o">.</span><span class="n">Extract</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">inliers</span> <span class="o">=</span> <span class="n">cloud_data</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">negative</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">outliers</span> <span class="o">=</span> <span class="n">cloud_data</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">negative</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inliers</span> <span class="o">&gt;</span> <span class="n">min_size</span><span class="p">:</span>
            <span class="n">inliers_p</span><span class="p">,</span> <span class="n">outliers_p</span><span class="p">,</span> <span class="n">coeff_p</span> <span class="o">=</span> <span class="n">do_plane_ransac</span><span class="p">(</span><span class="n">inliers</span><span class="p">)</span>
            <span class="n">new_cloud_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inliers_p</span><span class="p">)</span>
            <span class="n">normal_vector</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff_p</span><span class="p">)</span>
            <span class="n">outliers_data</span> <span class="o">=</span> <span class="n">outliers</span>
    <span class="k">return</span> <span class="n">new_cloud_data</span><span class="p">,</span> <span class="n">normal_vector</span><span class="p">,</span> <span class="n">outliers_data</span></div>

    <span class="c1"># while True:</span>
    <span class="c1">#     if cloud_data.size &gt; min_size:</span>
    <span class="c1">#         tree = cloud_data.make_kdtree()</span>
    <span class="c1">#         segment = cloud_data.make_EuclideanClusterExtraction()</span>
    <span class="c1">#         segment.set_ClusterTolerance(0.5)</span>
    <span class="c1">#         segment.set_MinClusterSize(min_size)</span>
    <span class="c1">#         segment.set_MaxClusterSize(max_size)</span>
    <span class="c1">#         segment.set_SearchMethod(tree)</span>
    <span class="c1">#         cluster_indices = segment.Extract()</span>
    <span class="c1">#         if len(cluster_indices) != 0:</span>
    <span class="c1">#             inliers = cloud_data.extract(cluster_indices[0], negative=False)</span>
    <span class="c1">#             outliers = cloud_data.extract(cluster_indices[0], negative=True)</span>
    <span class="c1">#             if inliers &gt; min_size:</span>
    <span class="c1">#                 inliers_p, outliers_p, coeff_p = do_plane_ransac(inliers)</span>
    <span class="c1">#                 new_cloud_data.append(inliers_p)</span>
    <span class="c1">#                 normal_vector.append(coeff_p)</span>
    <span class="c1">#                 cloud_data = outliers</span>
    <span class="c1">#             else:</span>
    <span class="c1">#                 if outliers.size &gt; min_size:</span>
    <span class="c1">#                     cloud_data = outliers</span>
    <span class="c1">#                 else:</span>
    <span class="c1">#                     break</span>
    <span class="c1">#         else:</span>
    <span class="c1">#             break</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         break</span>
    <span class="c1"># if len(cloud_point) &gt;= 2:</span>
    <span class="c1">#     visual_viewer(cloud_point)</span>
    <span class="c1"># return new_cloud_data, normal_vector</span>
<div class="viewcode-block" id="merge_dup_plane"><a class="viewcode-back" href="../../main.plane_ransac_test.html#main.plane_ransac_test.merge_dup_plane">[docs]</a><span class="k">def</span> <span class="nf">merge_dup_plane</span><span class="p">(</span><span class="n">plane_list</span><span class="p">,</span> <span class="n">normal_vector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Merging the parallel planes</span>

<span class="sd">        If the planes are parallel and the bounding boxes overlap, they are merged into one plane.</span>


<span class="sd">    :param list plane_list: PointCloud data list</span>
<span class="sd">    :param list normal_vector: Coefficient data list of each plane</span>

<span class="sd">    :returns: list new_plane_list: Data list of newly created PointClouds</span>
<span class="sd">    :returns: list new_normal_vector: Coefficient data list of each planes</span>
<span class="sd">    :returns: list new_bbox_list: Bounding box information of each PointCloud</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_plane_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">new_normal_vector</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">new_bbox_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">prev_bbox</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">plane_list</span><span class="p">))]</span>
    <span class="n">dup_plane_index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">plane_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">plane_list</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev_bbox</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">main_bbox</span> <span class="o">=</span> <span class="n">get_range</span><span class="p">(</span><span class="n">plane_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mf">0.2</span><span class="p">)</span>
                <span class="n">prev_bbox</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">main_bbox</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">main_bbox</span> <span class="o">=</span> <span class="n">prev_bbox</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev_bbox</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sub_bbox</span> <span class="o">=</span> <span class="n">get_range</span><span class="p">(</span><span class="n">plane_list</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="mf">0.2</span><span class="p">)</span>
                <span class="n">prev_bbox</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sub_bbox</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sub_bbox</span> <span class="o">=</span> <span class="n">prev_bbox</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">check_bbox</span><span class="p">(</span><span class="n">main_bbox</span><span class="p">,</span> <span class="n">sub_bbox</span><span class="p">):</span>
                <span class="n">model_cos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">normal_vector</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">normal_vector</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">normal_vector</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]],</span>
                    <span class="p">[</span><span class="n">normal_vector</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">normal_vector</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">normal_vector</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]])</span> \
                            <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">normal_vector</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">normal_vector</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">normal_vector</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]])</span>
                               <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">normal_vector</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">normal_vector</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">normal_vector</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]]))</span>

                <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">model_cos</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>

                    <span class="n">main_point</span> <span class="o">=</span> <span class="n">plane_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">distance_bw_planes</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">normal_vector</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">main_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">normal_vector</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">main_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">normal_vector</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">main_point</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">normal_vector</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span> <span class="o">/</span> \
                                        <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">normal_vector</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">normal_vector</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">normal_vector</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="mi">2</span><span class="p">))</span>
                    
                    <span class="k">if</span> <span class="n">distance_bw_planes</span> <span class="o">&lt;=</span> <span class="mf">0.1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dup_plane_index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">dup_plane_index</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">check_value</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">for</span> <span class="n">dup_index</span> <span class="ow">in</span> <span class="n">dup_plane_index</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dup_index</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dup_index</span><span class="p">:</span>
                                        <span class="n">dup_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                                        <span class="n">check_value</span> <span class="o">=</span> <span class="kc">True</span>
                                        <span class="k">break</span>
                            <span class="k">if</span> <span class="n">check_value</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                                <span class="n">dup_plane_index</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dup_plane_index</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">dup_index</span> <span class="ow">in</span> <span class="n">dup_plane_index</span><span class="p">:</span>
            
            <span class="n">max_i</span> <span class="o">=</span> <span class="n">dup_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">merge_point</span> <span class="o">=</span> <span class="n">plane_list</span><span class="p">[</span><span class="n">dup_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">each_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dup_index</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">plane_list</span><span class="p">[</span><span class="n">max_i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">plane_list</span><span class="p">[</span><span class="n">dup_index</span><span class="p">[</span><span class="n">each_i</span><span class="p">]]</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                    <span class="n">max_i</span> <span class="o">=</span> <span class="n">dup_index</span><span class="p">[</span><span class="n">each_i</span><span class="p">]</span>
                <span class="n">merge_point</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">plane_list</span><span class="p">[</span><span class="n">dup_index</span><span class="p">[</span><span class="n">each_i</span><span class="p">]]</span><span class="o">.</span><span class="n">to_list</span><span class="p">())</span>
            <span class="n">merge_plane</span> <span class="o">=</span> <span class="n">pcl</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">()</span>
            <span class="n">merge_plane</span><span class="o">.</span><span class="n">from_list</span><span class="p">(</span><span class="n">merge_point</span><span class="p">)</span>
            <span class="n">new_plane_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">merge_plane</span><span class="p">)</span>
            <span class="n">new_normal_vector</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">normal_vector</span><span class="p">[</span><span class="n">max_i</span><span class="p">])</span>
            <span class="n">new_bbox_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prev_bbox</span><span class="p">[</span><span class="n">max_i</span><span class="p">])</span>
        <span class="n">all_dup_index</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span> <span class="n">dup_plane_index</span><span class="p">)</span>

        
        <span class="k">for</span> <span class="n">each_plane_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">plane_list</span><span class="p">)):</span>
            
            <span class="k">if</span> <span class="n">each_plane_i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_dup_index</span><span class="p">:</span>
                <span class="n">new_plane_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plane_list</span><span class="p">[</span><span class="n">each_plane_i</span><span class="p">])</span>
                <span class="n">new_normal_vector</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">normal_vector</span><span class="p">[</span><span class="n">each_plane_i</span><span class="p">])</span>
                <span class="n">new_bbox_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prev_bbox</span><span class="p">[</span><span class="n">each_plane_i</span><span class="p">])</span>
                

        <span class="k">return</span> <span class="n">new_plane_list</span><span class="p">,</span> <span class="n">new_normal_vector</span><span class="p">,</span> <span class="n">new_bbox_list</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">plane_list</span><span class="p">,</span> <span class="n">normal_vector</span><span class="p">,</span> <span class="n">prev_bbox</span></div>



<div class="viewcode-block" id="get_plane_list"><a class="viewcode-back" href="../../main.plane_ransac_test.html#main.plane_ransac_test.get_plane_list">[docs]</a><span class="k">def</span> <span class="nf">get_plane_list</span><span class="p">(</span><span class="n">clustered_cloud</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Planar data extraction from clustered cloud</span>

<span class="sd">    Execute the loop statement until the cloud size is greater than</span>
<span class="sd">    or equal to the clustered_cloud size * min_percentage value.</span>
<span class="sd">    During loop statement execution, Plane RANSAC is executed.</span>
<span class="sd">    Maintain a loop statement by updating information that is not extracted by plane with cloud data.</span>

<span class="sd">   </span>
<span class="sd">    :param list clustered_cloud: Clustered data from original data</span>

<span class="sd">    </span>
<span class="sd">    :returns: list new_plane_list: List of Pointcloud data extracted by plane</span>
<span class="sd">    :returns: list new_normal_vector: Coefficient data list of each planes</span>
<span class="sd">    :returns: list new_bbox_list: Bounding box information of each PointCloud</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">plane_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">normal_vector</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

    <span class="n">cloud</span> <span class="o">=</span> <span class="n">clustered_cloud</span>


    <span class="n">original_size</span> <span class="o">=</span> <span class="n">cloud</span><span class="o">.</span><span class="n">size</span>
    <span class="n">min_percentage</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        

        <span class="k">if</span> <span class="n">cloud</span><span class="o">.</span><span class="n">height</span> <span class="o">*</span> <span class="n">cloud</span><span class="o">.</span><span class="n">width</span> <span class="o">&lt;</span> <span class="n">original_size</span> <span class="o">*</span> <span class="n">min_percentage</span> <span class="o">/</span> <span class="mi">100</span><span class="p">:</span>

            <span class="k">break</span>

        <span class="n">inliers_p</span><span class="p">,</span> <span class="n">outliers_p</span><span class="p">,</span> <span class="n">coeff_p</span> <span class="o">=</span> <span class="n">do_plane_ransac</span><span class="p">(</span><span class="n">cloud</span><span class="p">)</span>
        <span class="n">default_vector</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">model_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">coeff_p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coeff_p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">coeff_p</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">model_cos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">default_vector</span><span class="p">,</span> <span class="n">model_value</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">model_value</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">default_vector</span><span class="p">))</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">model_cos</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.8</span><span class="p">:</span>
            <span class="n">clustered_plane_list</span><span class="p">,</span> <span class="n">clustered_plane_coeff</span><span class="p">,</span> <span class="n">outliers_data</span> <span class="o">=</span> <span class="n">plane_cluster</span><span class="p">(</span><span class="n">inliers_p</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clustered_plane_list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">plane_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">clustered_plane_list</span><span class="p">)</span>
                <span class="n">normal_vector</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">clustered_plane_coeff</span><span class="p">)</span>
                <span class="n">new_outliers_p</span> <span class="o">=</span> <span class="n">pcl</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">()</span>
                <span class="n">new_outliers_p</span><span class="o">.</span><span class="n">from_list</span><span class="p">(</span><span class="n">outliers_data</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span> <span class="o">+</span> <span class="n">outliers_p</span><span class="o">.</span><span class="n">to_list</span><span class="p">())</span>
                <span class="n">cloud</span> <span class="o">=</span> <span class="n">new_outliers_p</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cloud</span> <span class="o">=</span> <span class="n">outliers_p</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cloud</span> <span class="o">=</span> <span class="n">outliers_p</span>

    <span class="c1"># visual_viewer(plane_list)</span>
    <span class="n">new_plane_list</span><span class="p">,</span> <span class="n">new_normal_vector</span><span class="p">,</span> <span class="n">new_bbox_list</span> <span class="o">=</span> <span class="n">merge_dup_plane</span><span class="p">(</span><span class="n">plane_list</span><span class="p">,</span> <span class="n">normal_vector</span><span class="p">)</span>


    <span class="k">return</span> <span class="n">new_plane_list</span><span class="p">,</span> <span class="n">new_normal_vector</span><span class="p">,</span> <span class="n">new_bbox_list</span></div>


<div class="viewcode-block" id="make_wall_info"><a class="viewcode-back" href="../../main.plane_ransac_test.html#main.plane_ransac_test.make_wall_info">[docs]</a><span class="k">def</span> <span class="nf">make_wall_info</span><span class="p">(</span><span class="n">cloud</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Making the wall information using PointCloud data</span>

<span class="sd">        Clustering the original point cloud data.</span>
<span class="sd">        Extracting the plane data from the clustered data through Plane RANSAC</span>
<span class="sd">        Find intersections between extracted plane data and generate surface data</span>

<span class="sd">    Args:</span>
<span class="sd">        cloud: Original PointCloud data</span>

<span class="sd">    Returns:</span>
<span class="sd">        surface_point_list: A list consisting of a list of points that make up each surface</span>
<span class="sd">    &quot;&quot;&quot;</span>

    

    <span class="c1"># clustering the pointcloud data</span>
    <span class="n">cluster_list</span> <span class="o">=</span> <span class="n">clustering</span><span class="p">(</span><span class="n">cloud</span><span class="p">)</span>
    <span class="n">surface_point_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">p_s</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">Point_sort</span><span class="p">()</span>

    

    <span class="k">for</span> <span class="n">clustered_cloud</span> <span class="ow">in</span> <span class="n">cluster_list</span><span class="p">:</span>
        <span class="c1"># Exporting the plane data from each clustered cloud data</span>
        <span class="n">wall_point_list</span><span class="p">,</span> <span class="n">wall_vector_list</span><span class="p">,</span> <span class="n">wall_bbox_list</span> <span class="o">=</span> <span class="n">get_plane_list</span><span class="p">(</span><span class="n">clustered_cloud</span><span class="p">)</span>
        <span class="c1"># visual_viewer(wall_point_list)</span>
        

        <span class="n">side_line_count</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">side_line_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        
        <span class="k">for</span> <span class="n">wall_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">wall_point_list</span><span class="p">)):</span>
            <span class="n">side_line_info</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">side_line_info</span> <span class="o">=</span> <span class="n">make_side_line</span><span class="p">(</span><span class="n">wall_bbox_list</span><span class="p">[</span><span class="n">wall_index</span><span class="p">],</span> <span class="n">wall_vector_list</span><span class="p">[</span><span class="n">wall_index</span><span class="p">])</span>

            <span class="c1"># for a_i in side_line_info:</span>
            <span class="c1">#     a.extend(a_i)</span>
            <span class="c1"># p_s.visual_graph(a)</span>
            <span class="n">side_line_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">side_line_info</span><span class="p">)</span>
            <span class="n">side_line_count</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">side_line_info</span><span class="p">))</span>
        
        <span class="n">wall_surface_list</span> <span class="o">=</span> <span class="n">get_intersection_line</span><span class="p">(</span><span class="n">wall_bbox_list</span><span class="p">,</span> <span class="n">wall_vector_list</span><span class="p">,</span> <span class="n">side_line_list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">w_i</span> <span class="ow">in</span> <span class="n">wall_surface_list</span><span class="p">:</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">w_i</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">w_i</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">w_i</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">w_i</span><span class="p">:</span>
                <span class="n">a</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            
            <span class="n">c</span> <span class="o">=</span> <span class="n">p_s</span><span class="o">.</span><span class="n">SortPointsClockwise</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">surface_point_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">p_s</span><span class="o">.</span><span class="n">visual_graph</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># for wall_i in range(len(wall_surface_list)):</span>
        <span class="c1">#     if side_line_count[wall_i] == 0:</span>
        <span class="c1">#         merge_wall_info = reduce(lambda x, y: x+y, wall_surface_list[wall_i])</span>
        <span class="c1">#     else:</span>
        <span class="c1">#         if len(wall_surface_list[wall_i]) &gt;= 4:</span>
        <span class="c1">#             wall_surface_list[wall_i].pop(0)</span>
        <span class="c1">#             wall_surface_list[wall_i].pop(0)</span>
        <span class="c1">#         merge_wall_info = reduce(lambda x, y: x+y, wall_surface_list[wall_i])</span>
        <span class="c1">#     sorted_wall_info = p_s.SortPointsClockwise(merge_wall_info, True)</span>
        <span class="c1">#</span>
        <span class="c1">#     # p_s.visual_graph(sorted_wall_info)</span>




    <span class="c1">#     wall_surface_list = get_intersection_line(new_point_info, new_plane_info, new_line_info)</span>
        
        
    <span class="c1">#     new_wall_surface = []</span>
    <span class="c1">#     for wall_info in wall_surface_list:</span>
    <span class="c1">#</span>
    <span class="c1">#         if len(wall_info) != 0:</span>
    <span class="c1">#</span>
    <span class="c1">#             if len(wall_info) == 2:</span>
    <span class="c1">#                 line_1 = wall_info[0]</span>
    <span class="c1">#                 line_2 = wall_info[1]</span>
    <span class="c1">#</span>
    <span class="c1">#                 rectangle_points = line_1 + line_2</span>
    <span class="c1">#                 rectangle_points = np.asarray(rectangle_points)</span>
    <span class="c1">#</span>
    <span class="c1">#                 sorted_surface_info = ring_sort.SortPointsClockwise(rectangle_points.tolist(), False)</span>
    <span class="c1">#                 sorted_surface_info_2 = ring_sort.SortPointsClockwise(rectangle_points.tolist(), True)</span>
    <span class="c1">#                 # new_wall_surface.extend(sorted_surface_info)</span>
    <span class="c1">#                 surface_point_list.append(sorted_surface_info)</span>
    <span class="c1">#                 surface_point_list.append(sorted_surface_info_2)</span>
    <span class="c1">#</span>
    <span class="c1">#                 # new_wall_surface.extend(rectangle_points.tolist())</span>
    <span class="c1">#             elif len(wall_info) &gt; 2:</span>
    <span class="c1">#</span>
    <span class="c1">#                 rectangle_points = get_rectangle_points(wall_info)</span>
    <span class="c1">#                 rectangle_points = np.asarray(rectangle_points)</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                 sorted_surface_info = ring_sort.SortPointsClockwise(rectangle_points.tolist(), False)</span>
    <span class="c1">#                 sorted_surface_info_2 = ring_sort.SortPointsClockwise(rectangle_points.tolist(), True)</span>
    <span class="c1">#                 # new_wall_surface.extend(sorted_surface_info)</span>
    <span class="c1">#                 surface_point_list.append(sorted_surface_info)</span>
    <span class="c1">#                 surface_point_list.append(sorted_surface_info_2)</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                 # new_wall_surface.extend(rectangle_points.tolist())</span>
    <span class="c1">#             else:</span>
                    
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="k">return</span> <span class="n">surface_point_list</span></div>

<div class="viewcode-block" id="make_chair_info"><a class="viewcode-back" href="../../main.plane_ransac_test.html#main.plane_ransac_test.make_chair_info">[docs]</a><span class="k">def</span> <span class="nf">make_chair_info</span><span class="p">(</span><span class="n">cloud</span><span class="p">,</span> <span class="n">save_path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Making the chair information</span>

<span class="sd">        Clustering the chair data.</span>
<span class="sd">        And returns the bounding box of each clustered data</span>

<span class="sd">    </span>
<span class="sd">    :param pcl.PointCloud cloud: PointCloud data of chair</span>
<span class="sd">    :param string save_path: Save path of the clustered data</span>
<span class="sd">    </span>
<span class="sd">    :returns: list clustered_bbox: The bounding box of each clustered data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">chair_range</span> <span class="o">=</span> <span class="n">get_range</span><span class="p">(</span><span class="n">cloud</span><span class="o">.</span><span class="n">to_list</span><span class="p">())</span>
    <span class="n">cluster_list</span> <span class="o">=</span> <span class="n">clustering</span><span class="p">(</span><span class="n">cloud</span><span class="p">,</span> <span class="n">min_cluter_size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">main_area</span> <span class="o">=</span> <span class="n">get_area</span><span class="p">(</span><span class="n">chair_range</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">clustered_bbox</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">temp_cloud</span> <span class="o">=</span> <span class="n">cloud</span><span class="o">.</span><span class="n">to_array</span><span class="p">()</span>

        <span class="n">cloud_cluster</span> <span class="o">=</span> <span class="n">pcl</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">()</span>
        <span class="n">cloud_cluster</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">temp_cloud</span><span class="p">)</span>
        <span class="n">clustered_chair_range</span> <span class="o">=</span> <span class="n">get_range</span><span class="p">(</span><span class="n">temp_cloud</span><span class="p">)</span>
        <span class="n">clustered_bbox</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clustered_chair_range</span><span class="p">)</span>

        <span class="c1"># out_data_chair_filename = save_path + &quot;_clustered_chair_&quot; + str(0) + &quot;.pcd&quot;</span>
        <span class="c1"># pcl.save(cloud_cluster, out_data_chair_filename)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

            <span class="n">temp_cloud</span> <span class="o">=</span> <span class="n">cluster_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to_array</span><span class="p">()</span>

            <span class="n">cloud_cluster</span> <span class="o">=</span> <span class="n">pcl</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">()</span>
            <span class="n">cloud_cluster</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">temp_cloud</span><span class="p">)</span>
            <span class="n">clustered_chair_range</span> <span class="o">=</span> <span class="n">get_range</span><span class="p">(</span><span class="n">temp_cloud</span><span class="p">)</span>
            <span class="n">clustered_bbox</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clustered_chair_range</span><span class="p">)</span>
            <span class="c1"># out_data_chair_filename = save_path + &quot;_clustered_chair_&quot; + str(1) + &quot;.pcd&quot;</span>
            <span class="c1"># pcl.save(cloud_cluster, out_data_chair_filename)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">clustered_cloud</span> <span class="ow">in</span> <span class="n">cluster_list</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">temp_cloud</span> <span class="o">=</span> <span class="n">clustered_cloud</span><span class="o">.</span><span class="n">to_array</span><span class="p">()</span>

                <span class="n">clustered_chair_range</span> <span class="o">=</span> <span class="n">get_range</span><span class="p">(</span><span class="n">temp_cloud</span><span class="p">)</span>
                <span class="n">temp_area</span> <span class="o">=</span> <span class="n">get_area</span><span class="p">(</span><span class="n">clustered_chair_range</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">temp_area</span> <span class="o">&lt;=</span> <span class="n">main_area</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">:</span>
                    <span class="n">clustered_bbox</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clustered_chair_range</span><span class="p">)</span>
                    <span class="n">cloud_cluster</span> <span class="o">=</span> <span class="n">pcl</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">()</span>
                    <span class="n">cloud_cluster</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">temp_cloud</span><span class="p">)</span>
                    <span class="n">out_data_chair_filename</span> <span class="o">=</span> <span class="n">save_path</span> <span class="o">+</span> <span class="s2">&quot;_clustered_chair_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.pcd&quot;</span>
                    <span class="n">pcl</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">cloud_cluster</span><span class="p">,</span> <span class="n">out_data_chair_filename</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">clustered_bbox</span></div>

<div class="viewcode-block" id="get_range"><a class="viewcode-back" href="../../main.plane_ransac_test.html#main.plane_ransac_test.get_range">[docs]</a><span class="k">def</span> <span class="nf">get_range</span><span class="p">(</span><span class="n">point_cloud</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Making the bouning box information</span>

<span class="sd">        Finding the Minimum and Maximum points of X, Y and Z</span>
<span class="sd">        and add the epsilon value</span>
<span class="sd">    </span>
<span class="sd">    :param pcl.PointCloud point_cloud: PointCloud data</span>
<span class="sd">    :param float e: Epsilon value</span>

<span class="sd">    :returns: list [point_max2, point_min2]: Minimum and Maximum points of X, Y and Z</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="sd">&#39;&#39;&#39; 0.1 10cm&#39;&#39;&#39;</span>
    <span class="n">point_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">point_cloud</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">point_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">point_cloud</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>

    <span class="n">point_max2</span> <span class="o">=</span> <span class="n">point_max</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">e</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
    <span class="n">point_min2</span> <span class="o">=</span> <span class="n">point_min</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">e</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
    <span class="c1"># point_max = np.amax(np.asarray(point_cloud), axis=0)[0:3]</span>
    <span class="c1"># point_min = np.amin(np.asarray(point_cloud), axis=0)[0:3]</span>
    <span class="c1">#</span>
    <span class="c1"># point_max2 = np.asarray(point_max) + np.asarray([e, e, 0.0])</span>
    <span class="c1"># point_min2 = np.asarray(point_min) - np.asarray([e, e, 0.0])</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">point_max2</span><span class="p">,</span> <span class="n">point_min2</span><span class="p">]</span></div>

<div class="viewcode-block" id="get_area"><a class="viewcode-back" href="../../main.plane_ransac_test.html#main.plane_ransac_test.get_area">[docs]</a><span class="k">def</span> <span class="nf">get_area</span><span class="p">(</span><span class="n">bbox_range</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the size of the area</span>

<span class="sd">        Calculate the size of the area with data using a bounding box.</span>

<span class="sd">    </span>
<span class="sd">    :param list bbox_range: Bounding box information of PointCloud</span>

<span class="sd">    </span>
<span class="sd">    :returns: float area_info: size of the area</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">min_point</span> <span class="o">=</span> <span class="n">bbox_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">max_point</span> <span class="o">=</span> <span class="n">bbox_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">side_point_1</span> <span class="o">=</span> <span class="p">[</span><span class="n">max_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">min_point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">min_point</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
    <span class="n">side_point_2</span> <span class="o">=</span> <span class="p">[</span><span class="n">min_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">max_point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">min_point</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">side_point_1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">min_point</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">side_point_2</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">min_point</span><span class="p">))</span>
    <span class="n">area_info</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">area_info</span></div>

<div class="viewcode-block" id="make_side_line"><a class="viewcode-back" href="../../main.plane_ransac_test.html#main.plane_ransac_test.make_side_line">[docs]</a><span class="k">def</span> <span class="nf">make_side_line</span><span class="p">(</span><span class="n">bbox_info</span><span class="p">,</span> <span class="n">normal_vector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Making side lines of plane</span>

<span class="sd">        Using the bounding box and plane data, create straight lines at both ends of the plane.</span>

<span class="sd">    </span>
<span class="sd">    :param list bbox_info: Bounding box data of PointCloud</span>
<span class="sd">    :param list normal_vector: Coefficient data of plane</span>

<span class="sd">    </span>
<span class="sd">    :returns: list line_points_list: A list of the maximum and minimum points that can be made with straight lines at both ends</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">boundary_info</span> <span class="o">=</span> <span class="n">bbox_info</span>

    <span class="n">side_line_points</span> <span class="o">=</span> <span class="n">find_side_point</span><span class="p">(</span><span class="n">normal_vector</span><span class="p">,</span> <span class="n">boundary_info</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">side_line_points</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sorted_line_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">side_line_points</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">cmp_to_key</span><span class="p">(</span><span class="n">z_point_sorting</span><span class="p">))</span>

        <span class="n">match_i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">sorted_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">sorted_distance</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">sorted_j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_line_list</span><span class="p">)):</span>
                <span class="n">distance_point</span> <span class="o">=</span> <span class="n">distance_to_point</span><span class="p">(</span><span class="n">sorted_line_list</span><span class="p">[</span><span class="n">sorted_i</span><span class="p">],</span> <span class="n">sorted_line_list</span><span class="p">[</span><span class="n">sorted_j</span><span class="p">])</span>
                <span class="n">sorted_distance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distance_point</span><span class="p">)</span>

            <span class="n">min_i</span> <span class="o">=</span> <span class="n">sorted_distance</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">sorted_distance</span><span class="p">))</span>
            <span class="n">match_i</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">point_1</span> <span class="o">=</span> <span class="p">[</span><span class="n">sorted_line_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sorted_line_list</span><span class="p">[</span><span class="n">match_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
        <span class="n">point_2</span> <span class="o">=</span> <span class="p">[</span><span class="n">sorted_line_list</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sorted_line_list</span><span class="p">[</span><span class="n">match_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>
        <span class="n">line_points_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">line_points_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point_1</span><span class="p">)</span>
        <span class="n">line_points_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point_2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">line_points_list</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="make_straight"><a class="viewcode-back" href="../../main.plane_ransac_test.html#main.plane_ransac_test.make_straight">[docs]</a><span class="k">def</span> <span class="nf">make_straight</span><span class="p">(</span><span class="n">normal_vector</span><span class="p">,</span> <span class="n">boundary_point</span><span class="p">,</span> <span class="n">point_1</span><span class="p">,</span> <span class="n">point_2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Making the straight information and finding the intersect point</span>

<span class="sd">        Generate straight line data using point_1 and point_2.</span>
<span class="sd">        Finding the intersection point using normal_vector and straight line.</span>

<span class="sd">    </span>
<span class="sd">    :param list normal_vector: Coefficient data of plane</span>
<span class="sd">    :param list boundary_point: Bounding box data of PointCloud</span>
<span class="sd">    :param list point_1: A point that generates a straight line</span>
<span class="sd">    :param list point_2: A point that generates a straight line</span>

<span class="sd">    :returns: list intersect_point: The intersection of a plane and a straight line</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point_2</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point_1</span><span class="p">)</span>

    <span class="n">equation</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">normal_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">point_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span>
                  <span class="n">normal_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">point_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span>
                  <span class="n">normal_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">point_1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span>
                  <span class="n">normal_vector</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">equation</span><span class="p">,</span> <span class="n">t</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">point_x</span> <span class="o">=</span> <span class="n">point_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">point_y</span> <span class="o">=</span> <span class="n">point_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">point_z</span> <span class="o">=</span> <span class="n">point_1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">value</span><span class="p">)</span>

    <span class="n">intersect_point</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">point_x</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">point_y</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">point_z</span><span class="p">)]</span>

    <span class="c1"># check_result = check_point_range_2(point_list, boundary_point, 0.075)</span>
    <span class="n">check_result</span> <span class="o">=</span> <span class="n">check_point_range_2</span><span class="p">(</span><span class="n">intersect_point</span><span class="p">,</span> <span class="n">boundary_point</span><span class="p">)</span>
    

    <span class="k">if</span> <span class="n">check_result</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">intersect_point</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="find_side_point"><a class="viewcode-back" href="../../main.plane_ransac_test.html#main.plane_ransac_test.find_side_point">[docs]</a><span class="k">def</span> <span class="nf">find_side_point</span><span class="p">(</span><span class="n">plane_vector</span><span class="p">,</span> <span class="n">boundary_info</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create the intersection of the bounding box and the plane</span>

<span class="sd">        Creates the intersection of the edges and planes of the top and bottom faces of the bounding box</span>

<span class="sd">  </span>
<span class="sd">    :param list plane_vector: Coefficient data of plane</span>
<span class="sd">    :param list boundary_info: Bounding box data of PointCloud</span>

<span class="sd">   </span>
<span class="sd">    :returns: list point_list: List of points on both ends of a straight line</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># need to revising about that count of points is more than 4</span>
    <span class="n">min_point_low</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">boundary_info</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">boundary_info</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">boundary_info</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])]</span>
    <span class="n">min_point_top</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">boundary_info</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">boundary_info</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">boundary_info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])]</span>
    <span class="n">min_point_left</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">boundary_info</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">boundary_info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">boundary_info</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])]</span>
    <span class="n">min_point_right</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">boundary_info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">boundary_info</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">boundary_info</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])]</span>
    <span class="n">max_point_top</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">boundary_info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">boundary_info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">boundary_info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])]</span>
    <span class="n">max_point_low</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">boundary_info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">boundary_info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">boundary_info</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])]</span>
    <span class="n">max_point_right</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">boundary_info</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">boundary_info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">boundary_info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])]</span>
    <span class="n">max_point_left</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">boundary_info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">boundary_info</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">boundary_info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])]</span>
    <span class="n">min_line_1</span> <span class="o">=</span> <span class="n">make_straight</span><span class="p">(</span><span class="n">plane_vector</span><span class="p">,</span> <span class="n">boundary_info</span><span class="p">,</span> <span class="n">min_point_low</span><span class="p">,</span> <span class="n">min_point_right</span><span class="p">)</span>
    <span class="n">min_line_2</span> <span class="o">=</span> <span class="n">make_straight</span><span class="p">(</span><span class="n">plane_vector</span><span class="p">,</span> <span class="n">boundary_info</span><span class="p">,</span> <span class="n">min_point_low</span><span class="p">,</span> <span class="n">min_point_left</span><span class="p">)</span>
    <span class="n">min_line_3</span> <span class="o">=</span> <span class="n">make_straight</span><span class="p">(</span><span class="n">plane_vector</span><span class="p">,</span> <span class="n">boundary_info</span><span class="p">,</span> <span class="n">max_point_low</span><span class="p">,</span> <span class="n">min_point_right</span><span class="p">)</span>
    <span class="n">min_line_4</span> <span class="o">=</span> <span class="n">make_straight</span><span class="p">(</span><span class="n">plane_vector</span><span class="p">,</span> <span class="n">boundary_info</span><span class="p">,</span> <span class="n">max_point_low</span><span class="p">,</span> <span class="n">min_point_left</span><span class="p">)</span>

    <span class="n">max_line_1</span> <span class="o">=</span> <span class="n">make_straight</span><span class="p">(</span><span class="n">plane_vector</span><span class="p">,</span> <span class="n">boundary_info</span><span class="p">,</span> <span class="n">max_point_top</span><span class="p">,</span> <span class="n">max_point_right</span><span class="p">)</span>
    <span class="n">max_line_2</span> <span class="o">=</span> <span class="n">make_straight</span><span class="p">(</span><span class="n">plane_vector</span><span class="p">,</span> <span class="n">boundary_info</span><span class="p">,</span> <span class="n">max_point_top</span><span class="p">,</span> <span class="n">max_point_left</span><span class="p">)</span>
    <span class="n">max_line_3</span> <span class="o">=</span> <span class="n">make_straight</span><span class="p">(</span><span class="n">plane_vector</span><span class="p">,</span> <span class="n">boundary_info</span><span class="p">,</span> <span class="n">min_point_top</span><span class="p">,</span> <span class="n">max_point_right</span><span class="p">)</span>
    <span class="n">max_line_4</span> <span class="o">=</span> <span class="n">make_straight</span><span class="p">(</span><span class="n">plane_vector</span><span class="p">,</span> <span class="n">boundary_info</span><span class="p">,</span> <span class="n">min_point_top</span><span class="p">,</span> <span class="n">max_point_left</span><span class="p">)</span>

    <span class="n">min_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">min_line_1</span><span class="p">,</span> <span class="n">min_line_2</span><span class="p">,</span> <span class="n">min_line_3</span><span class="p">,</span> <span class="n">min_line_4</span><span class="p">]</span>
    <span class="n">max_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">max_line_1</span><span class="p">,</span> <span class="n">max_line_2</span><span class="p">,</span> <span class="n">max_line_3</span><span class="p">,</span> <span class="n">max_line_4</span><span class="p">]</span>

    <span class="n">point_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">max_index</span> <span class="ow">in</span> <span class="n">max_value</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_index</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">point_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_index</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">min_index</span> <span class="ow">in</span> <span class="n">min_value</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">min_index</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">point_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_index</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">point_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">point_list</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="check_point_range_2"><a class="viewcode-back" href="../../main.plane_ransac_test.html#main.plane_ransac_test.check_point_range_2">[docs]</a><span class="k">def</span> <span class="nf">check_point_range_2</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">wall_range</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check whether the pointer is included in the bounding box</span>

<span class="sd">        Check the pointer&#39;s X, Y and Z values are included in the bounding box</span>

<span class="sd">    </span>
<span class="sd">    :param list point: Pointer to check</span>
<span class="sd">    :param list wall_range: Information for bounding box</span>

<span class="sd">    </span>
<span class="sd">    :returns: boolean True: The pointer is included in the bounding box</span>
<span class="sd">    :returns: boolean False: The pointer is not included in the bounding box</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wall_range_max</span> <span class="o">=</span> <span class="n">wall_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">wall_range_min</span> <span class="o">=</span> <span class="n">wall_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">check_X</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">check_Z</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">check_Y</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">wall_range_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">wall_range_min</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">check_X</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">wall_range_max</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">wall_range_min</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">check_Y</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">z</span> <span class="o">&lt;=</span> <span class="n">wall_range_max</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">z</span> <span class="o">&gt;=</span> <span class="n">wall_range_min</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">check_Z</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">check_X</span> <span class="o">+</span> <span class="n">check_Z</span> <span class="o">+</span> <span class="n">check_Y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="check_bbox"><a class="viewcode-back" href="../../main.plane_ransac_test.html#main.plane_ransac_test.check_bbox">[docs]</a><span class="k">def</span> <span class="nf">check_bbox</span><span class="p">(</span><span class="n">main_bbox</span><span class="p">,</span> <span class="n">other_bbox</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check if the bounding box intersects</span>

<span class="sd">        Check if the bounding box intersects using the min and max points of the bounding box.</span>

<span class="sd">    </span>
<span class="sd">    :param list main_bbox: Information of main bounding box</span>
<span class="sd">    :param list other_bbox: Information of other bounding box</span>

<span class="sd">    </span>
<span class="sd">    :returns: boolean True: Bounding boxes intersect</span>
<span class="sd">    :returns: boolean False: Bounding boxes are not intersect</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m_minX</span> <span class="o">=</span> <span class="n">main_bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">m_minY</span> <span class="o">=</span> <span class="n">main_bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">m_minZ</span> <span class="o">=</span> <span class="n">main_bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">m_maxX</span> <span class="o">=</span> <span class="n">main_bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">m_maxY</span> <span class="o">=</span> <span class="n">main_bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">m_maxZ</span> <span class="o">=</span> <span class="n">main_bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">s_minX</span> <span class="o">=</span> <span class="n">other_bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">s_minY</span> <span class="o">=</span> <span class="n">other_bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">s_minZ</span> <span class="o">=</span> <span class="n">other_bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">s_maxX</span> <span class="o">=</span> <span class="n">other_bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">s_maxY</span> <span class="o">=</span> <span class="n">other_bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">s_maxZ</span> <span class="o">=</span> <span class="n">other_bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">m_minX</span> <span class="o">&lt;=</span> <span class="n">s_maxX</span> <span class="ow">and</span> <span class="n">m_maxX</span> <span class="o">&gt;=</span> <span class="n">s_minX</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">m_minY</span> <span class="o">&lt;=</span> <span class="n">s_maxY</span> <span class="ow">and</span> <span class="n">m_maxY</span> <span class="o">&gt;=</span> <span class="n">s_minY</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">m_minZ</span> <span class="o">&lt;=</span> <span class="n">s_maxZ</span> <span class="ow">and</span> <span class="n">m_maxZ</span> <span class="o">&gt;=</span> <span class="n">s_minZ</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_intersection_line"><a class="viewcode-back" href="../../main.plane_ransac_test.html#main.plane_ransac_test.get_intersection_line">[docs]</a><span class="k">def</span> <span class="nf">get_intersection_line</span><span class="p">(</span><span class="n">bbox_list</span><span class="p">,</span> <span class="n">normal_vector</span><span class="p">,</span> <span class="n">side_line_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create intersection points between planes</span>

<span class="sd">        Search intersecting lines between planes where each bounding box intersects.</span>
<span class="sd">        Create intersection points using information from the intersection lines and Maximum and Minimum height value for each plane</span>

<span class="sd">    :param list bbox_list: Bounding box information of each plane</span>
<span class="sd">    :param list normal_vector: Coefficient data list of each plane</span>
<span class="sd">    :param list side_line_list: Side lines list of each plane</span>

<span class="sd">    :returns: list side_line_list: side_line_list with each line intersection line information added</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="n">check_bbox_index</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">normal_vector</span><span class="p">))]</span>
    <span class="k">for</span> <span class="n">point_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bbox_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">temp_bbox</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">point_j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">point_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">bbox_list</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">check_bbox</span><span class="p">(</span><span class="n">bbox_list</span><span class="p">[</span><span class="n">point_i</span><span class="p">],</span> <span class="n">bbox_list</span><span class="p">[</span><span class="n">point_j</span><span class="p">]):</span>
                <span class="n">temp_bbox</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point_j</span><span class="p">)</span>
        <span class="n">check_bbox_index</span><span class="p">[</span><span class="n">point_i</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">temp_bbox</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">match_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">check_bbox_index</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">check_bbox_index</span><span class="p">[</span><span class="n">match_i</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sub_index</span> <span class="ow">in</span> <span class="n">check_bbox_index</span><span class="p">[</span><span class="n">match_i</span><span class="p">]:</span>
                <span class="n">model_cos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">normal_vector</span><span class="p">[</span><span class="n">match_i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">normal_vector</span><span class="p">[</span><span class="n">match_i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">normal_vector</span><span class="p">[</span><span class="n">match_i</span><span class="p">][</span><span class="mi">2</span><span class="p">]],</span>
                    <span class="p">[</span><span class="n">normal_vector</span><span class="p">[</span><span class="n">sub_index</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">normal_vector</span><span class="p">[</span><span class="n">sub_index</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">normal_vector</span><span class="p">[</span><span class="n">sub_index</span><span class="p">][</span><span class="mi">2</span><span class="p">]])</span> \
                            <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">normal_vector</span><span class="p">[</span><span class="n">match_i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">normal_vector</span><span class="p">[</span><span class="n">match_i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">normal_vector</span><span class="p">[</span><span class="n">match_i</span><span class="p">][</span><span class="mi">2</span><span class="p">]])</span>
                               <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">normal_vector</span><span class="p">[</span><span class="n">sub_index</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">normal_vector</span><span class="p">[</span><span class="n">sub_index</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                             <span class="n">normal_vector</span><span class="p">[</span><span class="n">sub_index</span><span class="p">][</span><span class="mi">2</span><span class="p">]]))</span>
                <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">model_cos</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
                    <span class="n">temp_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">normal_vector</span><span class="p">[</span><span class="n">match_i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">normal_vector</span><span class="p">[</span><span class="n">match_i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">normal_vector</span><span class="p">[</span><span class="n">match_i</span><span class="p">][</span><span class="mi">2</span><span class="p">]],</span>
                        <span class="p">[</span><span class="n">normal_vector</span><span class="p">[</span><span class="n">sub_index</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">normal_vector</span><span class="p">[</span><span class="n">sub_index</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">normal_vector</span><span class="p">[</span><span class="n">sub_index</span><span class="p">][</span><span class="mi">2</span><span class="p">]])</span>
                    <span class="n">e1</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span>
                        <span class="n">normal_vector</span><span class="p">[</span><span class="n">match_i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">normal_vector</span><span class="p">[</span><span class="n">match_i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">normal_vector</span><span class="p">[</span><span class="n">match_i</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span>
                        <span class="mi">0</span><span class="p">)</span>
                    <span class="n">e2</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span>
                        <span class="n">normal_vector</span><span class="p">[</span><span class="n">sub_index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">normal_vector</span><span class="p">[</span><span class="n">sub_index</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span>
                        <span class="n">normal_vector</span><span class="p">[</span><span class="n">sub_index</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span>
                        <span class="mi">0</span><span class="p">)</span>

                    <span class="n">value_eq</span> <span class="o">=</span> <span class="n">solve</span><span class="p">([</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                    <span class="n">temp_list</span> <span class="o">=</span> <span class="n">temp_list</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="n">temp_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value_eq</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
                    <span class="n">temp_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value_eq</span><span class="p">[</span><span class="n">y</span><span class="p">])</span>
                    <span class="n">temp_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

                    <span class="n">temp_point_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

                    <span class="n">main_minZ</span> <span class="o">=</span> <span class="n">bbox_list</span><span class="p">[</span><span class="n">match_i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">main_maxZ</span> <span class="o">=</span> <span class="n">bbox_list</span><span class="p">[</span><span class="n">match_i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">sub_minZ</span> <span class="o">=</span> <span class="n">bbox_list</span><span class="p">[</span><span class="n">sub_index</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">sub_maxZ</span> <span class="o">=</span> <span class="n">bbox_list</span><span class="p">[</span><span class="n">sub_index</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>

                    <span class="n">minT</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span> <span class="o">-</span> <span class="n">temp_list</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">/</span> <span class="n">temp_list</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">minX</span> <span class="o">=</span> <span class="p">(</span><span class="n">minT</span> <span class="o">*</span> <span class="n">temp_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">temp_list</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                    <span class="n">minY</span> <span class="o">=</span> <span class="p">(</span><span class="n">minT</span> <span class="o">*</span> <span class="n">temp_list</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">temp_list</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

                    <span class="n">main_point_bot</span> <span class="o">=</span> <span class="p">[</span><span class="n">minX</span><span class="p">,</span> <span class="n">minY</span><span class="p">,</span> <span class="n">main_minZ</span><span class="p">]</span>
                    <span class="n">main_point_top</span> <span class="o">=</span> <span class="p">[</span><span class="n">minX</span><span class="p">,</span> <span class="n">minY</span><span class="p">,</span> <span class="n">main_maxZ</span><span class="p">]</span>
                    <span class="n">sub_point_bot</span> <span class="o">=</span> <span class="p">[</span><span class="n">minX</span><span class="p">,</span> <span class="n">minY</span><span class="p">,</span> <span class="n">sub_minZ</span><span class="p">]</span>
                    <span class="n">sub_point_top</span> <span class="o">=</span> <span class="p">[</span><span class="n">minX</span><span class="p">,</span> <span class="n">minY</span><span class="p">,</span> <span class="n">sub_maxZ</span><span class="p">]</span>
                    <span class="n">main_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">main_point_bot</span><span class="p">,</span> <span class="n">main_point_top</span><span class="p">]</span>
                    <span class="n">sub_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">sub_point_bot</span><span class="p">,</span> <span class="n">sub_point_top</span><span class="p">]</span>
                    <span class="n">side_line_list</span><span class="p">[</span><span class="n">match_i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">main_points</span><span class="p">)</span>
                    <span class="n">side_line_list</span><span class="p">[</span><span class="n">sub_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_points</span><span class="p">)</span>
                    <span class="c1"># if included_bbox(bbox_list[match_i], bbox_list[sub_index]) == 2:</span>
                    <span class="c1">#     side_line_list[match_i].append(main_points)</span>
                    <span class="c1">#     side_line_list[match_i].append(sub_points)</span>
                    <span class="c1">#     side_line_list[sub_index].append(sub_points)</span>
                    <span class="c1">#</span>
                    <span class="c1"># elif included_bbox(bbox_list[match_i], bbox_list[sub_index]) == -2:</span>
                    <span class="c1">#     side_line_list[sub_index].append(sub_points)</span>
                    <span class="c1">#     side_line_list[sub_index].append(main_points)</span>
                    <span class="c1">#     side_line_list[match_i].append(main_points)</span>
                    <span class="c1"># else:</span>
                    <span class="c1">#     side_line_list[match_i].append(main_points)</span>
                    <span class="c1">#     side_line_list[sub_index].append(sub_points)</span>

    <span class="k">return</span> <span class="n">side_line_list</span></div>

<div class="viewcode-block" id="visual_graph"><a class="viewcode-back" href="../../main.plane_ransac_test.html#main.plane_ransac_test.visual_graph">[docs]</a><span class="k">def</span> <span class="nf">visual_graph</span><span class="p">(</span><span class="n">point_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Visualize point list as graph</span>

<span class="sd">    </span>
<span class="sd">    :param list point_list: list of Points</span>

<span class="sd">    :returns: plt Visualize point list as graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">point_list</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
            <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;stars&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span>
                <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
    <span class="c1"># x = []</span>
    <span class="c1"># y = []</span>
    
    <span class="c1"># for index in point_list:</span>
    <span class="c1">#     x.append(index[0])</span>
    <span class="c1">#     y.append(index[2])</span>
    <span class="c1"># plt.scatter(x, y, label=&quot;stars&quot;, color=&quot;green&quot;,</span>
    <span class="c1">#             marker=&quot;*&quot;, s=50)</span>
    <span class="c1"># plt.plot(x, y)</span>
    <span class="c1"># plt.legend()</span>
    <span class="c1"># plt.show()</span>

<div class="viewcode-block" id="distance_to_point"><a class="viewcode-back" href="../../main.plane_ransac_test.html#main.plane_ransac_test.distance_to_point">[docs]</a><span class="k">def</span> <span class="nf">distance_to_point</span><span class="p">(</span><span class="n">point1</span><span class="p">,</span> <span class="n">point2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the distance between two points</span>

<span class="sd">   </span>
<span class="sd">    :param list point1: information of point (x, y, z)</span>
<span class="sd">    :param list point2: information of point (x, y, z)</span>

<span class="sd">    :returns: float d: the distance between two points</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">point1_x</span> <span class="o">=</span> <span class="n">point1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">point1_y</span> <span class="o">=</span> <span class="n">point1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">point1_z</span> <span class="o">=</span> <span class="n">point1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">point2_x</span> <span class="o">=</span> <span class="n">point2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">point2_y</span> <span class="o">=</span> <span class="n">point2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">point2_z</span> <span class="o">=</span> <span class="n">point2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">point1_x</span> <span class="o">-</span> <span class="n">point2_x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">point1_y</span> <span class="o">-</span> <span class="n">point2_y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">point1_z</span> <span class="o">-</span> <span class="n">point2_z</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="visual_viewer"><a class="viewcode-back" href="../../main.plane_ransac_test.html#main.plane_ransac_test.visual_viewer">[docs]</a><span class="k">def</span> <span class="nf">visual_viewer</span><span class="p">(</span><span class="n">cloud_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Visualizing Pointcloud data</span>

<span class="sd">   </span>
<span class="sd">    :param list cloud_list: list of PointClouds</span>

<span class="sd">    :returns: pcl.pcl_visualization Visualizing Pointclouds data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">viewer</span> <span class="o">=</span> <span class="n">pcl</span><span class="o">.</span><span class="n">pcl_visualization</span><span class="o">.</span><span class="n">PCLVisualizering</span><span class="p">(</span><span class="s1">&#39;3D Viewer&#39;</span><span class="p">)</span>

    <span class="n">viewer</span><span class="o">.</span><span class="n">SetBackgroundColor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># viewer.AddPointCloud(cloud_value, b&#39;sample cloud&#39;)</span>
    <span class="c1"># viewer.SetPointCloudRenderingProperties(pcl.pcl_visualization.PCLVISUALIZER_POINT_SIZE, 1, b&#39;sample cloud&#39;)</span>
    <span class="c1"># viewer.AddPointCloud(ceiling_cloud, b&#39;sample cloud1&#39;)</span>
    <span class="c1"># viewer.SetPointCloudRenderingProperties(pcl.pcl_visualization.PCLVISUALIZER_POINT_SIZE, 1, b&#39;sample cloud1&#39;)</span>
    <span class="n">r_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">b_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">g_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">r_num</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
    <span class="n">b_num</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
    <span class="n">g_num</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cloud_list</span><span class="p">)):</span>
        <span class="k">while</span> <span class="n">r_num</span> <span class="ow">in</span> <span class="n">r_list</span><span class="p">:</span>
            <span class="n">r_num</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
        <span class="n">r_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r_num</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">b_num</span> <span class="ow">in</span> <span class="n">b_list</span><span class="p">:</span>
            <span class="n">b_num</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
        <span class="n">b_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b_num</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">g_num</span> <span class="ow">in</span> <span class="n">g_list</span><span class="p">:</span>
            <span class="n">g_num</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
        <span class="n">g_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g_num</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cloud_list</span><span class="p">)):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">g_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

        <span class="n">point_size</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">color_handle</span> <span class="o">=</span> <span class="n">pcl</span><span class="o">.</span><span class="n">pcl_visualization</span><span class="o">.</span><span class="n">PointCloudColorHandleringCustom</span><span class="p">(</span><span class="n">cloud_list</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">r</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
        <span class="nb">id</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;inliers_cloud_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">viewer</span><span class="o">.</span><span class="n">AddPointCloud_ColorHandler</span><span class="p">(</span><span class="n">cloud_list</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">color_handle</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span>
        <span class="n">viewer</span><span class="o">.</span><span class="n">SetPointCloudRenderingProperties</span><span class="p">(</span><span class="n">pcl</span><span class="o">.</span><span class="n">pcl_visualization</span><span class="o">.</span><span class="n">PCLVISUALIZER_POINT_SIZE</span><span class="p">,</span> <span class="n">point_size</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span>

    <span class="n">viewer</span><span class="o">.</span><span class="n">InitCameraParameters</span><span class="p">()</span>
    <span class="k">while</span> <span class="n">viewer</span><span class="o">.</span><span class="n">WasStopped</span><span class="p">()</span> <span class="o">!=</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">viewer</span><span class="o">.</span><span class="n">SpinOnce</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span></div>

<div class="viewcode-block" id="visual_viewer2"><a class="viewcode-back" href="../../main.plane_ransac_test.html#main.plane_ransac_test.visual_viewer2">[docs]</a><span class="k">def</span> <span class="nf">visual_viewer2</span><span class="p">(</span><span class="n">cloud</span><span class="p">,</span> <span class="n">cloud_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Visualizing Pointcloud data</span>

<span class="sd">    </span>
<span class="sd">    :param pcl.PointCloud cloud: Original PointCloud data</span>
<span class="sd">    :param list cloud_list: list of PointClouds</span>

<span class="sd">    :returns: pcl.pcl_visualization Visualizing PointClouds data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">viewer</span> <span class="o">=</span> <span class="n">pcl</span><span class="o">.</span><span class="n">pcl_visualization</span><span class="o">.</span><span class="n">PCLVisualizering</span><span class="p">(</span><span class="s1">&#39;3D Viewer&#39;</span><span class="p">)</span>

    <span class="n">viewer</span><span class="o">.</span><span class="n">SetBackgroundColor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">viewer</span><span class="o">.</span><span class="n">AddPointCloud</span><span class="p">(</span><span class="n">cloud</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;sample cloud&#39;</span><span class="p">)</span>
    <span class="n">viewer</span><span class="o">.</span><span class="n">SetPointCloudRenderingProperties</span><span class="p">(</span><span class="n">pcl</span><span class="o">.</span><span class="n">pcl_visualization</span><span class="o">.</span><span class="n">PCLVISUALIZER_POINT_SIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;sample cloud&#39;</span><span class="p">)</span>

    <span class="n">r_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">b_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">g_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">r_num</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
    <span class="n">b_num</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
    <span class="n">g_num</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cloud_list</span><span class="p">)):</span>
        <span class="k">while</span> <span class="n">r_num</span> <span class="ow">in</span> <span class="n">r_list</span><span class="p">:</span>
            <span class="n">r_num</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
        <span class="n">r_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r_num</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">b_num</span> <span class="ow">in</span> <span class="n">b_list</span><span class="p">:</span>
            <span class="n">b_num</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
        <span class="n">b_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b_num</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">g_num</span> <span class="ow">in</span> <span class="n">g_list</span><span class="p">:</span>
            <span class="n">g_num</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
        <span class="n">g_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g_num</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cloud_list</span><span class="p">)):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">g_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

        <span class="n">point_size</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="n">color_handle</span> <span class="o">=</span> <span class="n">pcl</span><span class="o">.</span><span class="n">pcl_visualization</span><span class="o">.</span><span class="n">PointCloudColorHandleringCustom</span><span class="p">(</span><span class="n">cloud_list</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">r</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
        <span class="nb">id</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;inliers_cloud_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">viewer</span><span class="o">.</span><span class="n">AddPointCloud_ColorHandler</span><span class="p">(</span><span class="n">cloud_list</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">color_handle</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span>
        <span class="n">viewer</span><span class="o">.</span><span class="n">SetPointCloudRenderingProperties</span><span class="p">(</span><span class="n">pcl</span><span class="o">.</span><span class="n">pcl_visualization</span><span class="o">.</span><span class="n">PCLVISUALIZER_POINT_SIZE</span><span class="p">,</span> <span class="n">point_size</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span>

    <span class="n">viewer</span><span class="o">.</span><span class="n">InitCameraParameters</span><span class="p">()</span>
    <span class="k">while</span> <span class="n">viewer</span><span class="o">.</span><span class="n">WasStopped</span><span class="p">()</span> <span class="o">!=</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">viewer</span><span class="o">.</span><span class="n">SpinOnce</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span></div>

<div class="viewcode-block" id="z_point_sorting"><a class="viewcode-back" href="../../main.plane_ransac_test.html#main.plane_ransac_test.z_point_sorting">[docs]</a><span class="k">def</span> <span class="nf">z_point_sorting</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sorting tha data using z-value</span>

<span class="sd">    </span>
<span class="sd">    :param float x: Present point</span>
<span class="sd">    :param float y: Next point</span>

<span class="sd">    </span>
<span class="sd">    :returns: int -1: Present z-value of point is less than next z-value</span>
<span class="sd">    :returns: int 1: Present z-value of point is not less than next z-value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="cmp_to_key"><a class="viewcode-back" href="../../main.plane_ransac_test.html#main.plane_ransac_test.cmp_to_key">[docs]</a><span class="k">def</span> <span class="nf">cmp_to_key</span><span class="p">(</span><span class="n">mycmp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a cmp= function into a key= function&quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">K</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span>

        <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">mycmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">mycmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="n">K</span></div>
<span class="c1"># def make_rectangle(rectangle_point):</span>
<span class="c1">#     side1_bottom = rectangle_point[0][0]</span>
<span class="c1">#     side1_top = rectangle_point[0][1]</span>
<span class="c1">#</span>
<span class="c1">#     side2_bottom = rectangle_point[1][0]</span>
<span class="c1">#     side2_top = rectangle_point[1][1]</span>
<span class="c1">#</span>
<span class="c1">#     line_top = (np.asarray(side1_top) - np.asarray(side2_top)).tolist() + side2_top</span>
<span class="c1">#     line_bottom = (np.asarray(side1_bottom) - np.asarray(side2_bottom)).tolist() + side2_bottom</span>
<span class="c1">#     # line_side1 = (np.asarray(side1_top) - np.asarray(side1_bottom)).tolist() + side1_bottom</span>
<span class="c1">#     # line_side2 = (np.asarray(side2_top) - np.asarray(side2_bottom)).tolist() + side2_bottom</span>
<span class="c1">#</span>
<span class="c1">#     return [line_top, line_bottom]</span>
<span class="c1"># def get_rectangle_points2(wall_info):</span>
<span class="c1">#     side_1 = wall_info[0]</span>
<span class="c1">#     side_2 = wall_info[len(wall_info) - 1]</span>
<span class="c1">#</span>
<span class="c1">#     if len(wall_info) == 3:</span>
<span class="c1">#         d_value_1 = np.asarray(side_1[0]) - np.asarray(wall_info[1][0])</span>
<span class="c1">#         # d_1 = math.fabs(d_value_1[0]) + math.fabs(d_value_1[1])</span>
<span class="c1">#         d_1 = math.sqrt(math.pow(d_value_1[0], 2) + math.pow(d_value_1[1], 2))</span>
<span class="c1">#</span>
<span class="c1">#         d_value_2 = np.asarray(side_2[0]) - np.asarray(wall_info[1][0])</span>
<span class="c1">#         # d_2 = math.fabs(d_value_2[0]) + math.fabs(d_value_2[1])</span>
<span class="c1">#         d_2 = math.sqrt(math.pow(d_value_2[0], 2) + math.pow(d_value_2[1], 2))</span>
        
<span class="c1">#         if d_1 &gt; d_2:</span>
<span class="c1">#             return side_1 + wall_info[1]</span>
<span class="c1">#         elif d_1 &lt; d_2:</span>
<span class="c1">#             return side_2 + wall_info[1]</span>
<span class="c1">#         else:</span>
<span class="c1">#             return side_1 + side_2</span>
<span class="c1">#     else:</span>
<span class="c1">#         distance_list = list()</span>
<span class="c1">#         index_list = list()</span>
<span class="c1">#         for value in range(1, len(wall_info) - 1):</span>
<span class="c1">#             d_value = np.asarray(side_1[0]) - np.asarray(wall_info[value][0])</span>
<span class="c1">#             # d = math.fabs(d_value[0]) + math.fabs(d_value[1])</span>
<span class="c1">#             d = math.sqrt(math.pow(d_value[0], 2) + math.pow(d_value[1], 2))</span>
<span class="c1">#             if d_value[2] != 0:</span>
                
<span class="c1">#             distance_list.append(d)</span>
<span class="c1">#             index_list.append(value)</span>
<span class="c1">#</span>
<span class="c1">#         center_point = get_center_point(side_1 + side_2)</span>
<span class="c1">#         center_point -= side_1[0]</span>
<span class="c1">#         # to_center_d1 = math.fabs(center_point[0]) + math.fabs(center_point[1])</span>
<span class="c1">#         to_center_d1 = math.sqrt(math.pow(center_point[0], 2) + math.pow(center_point[1], 2))</span>
<span class="c1">#</span>
<span class="c1">#         max_d = np.amax(np.asarray(distance_list))</span>
<span class="c1">#         min_d = np.amin(np.asarray(distance_list))</span>
<span class="c1">#</span>
<span class="c1">#         min_i = np.argmin(np.asarray(distance_list))</span>
<span class="c1">#         max_i = np.argmax(np.asarray(distance_list))</span>
<span class="c1">#</span>
<span class="c1">#         index_2 = index_list[int(max_i)]</span>
<span class="c1">#         index_1 = index_list[int(min_i)]</span>
<span class="c1">#</span>
<span class="c1">#         if math.fabs(min_d - max_d) &lt;= 0.5:</span>
<span class="c1">#             if index_2 != index_1:</span>
<span class="c1">#                 if max_d &lt; to_center_d1:</span>
<span class="c1">#                     return wall_info[index_1] + side_2</span>
<span class="c1">#                 elif min_d &gt; to_center_d1:</span>
<span class="c1">#                     return wall_info[index_2] + side_1</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     return wall_info[index_1] + wall_info[index_2]</span>
<span class="c1">#             else:</span>
<span class="c1">#                 return side_1 + side_2</span>
<span class="c1">#         else:</span>
<span class="c1">#             return wall_info[index_1] + wall_info[index_2]</span>
<span class="c1">#         if max_d &lt; to_center_d1:</span>
<span class="c1">#             return wall_info[index_1] + side_2</span>
<span class="c1">#         elif min_d &gt; to_center_d1:</span>
<span class="c1">#             return wall_info[index_2] + side_1</span>
<span class="c1">#         else:</span>
<span class="c1">#             if index_1 == index_2:</span>
<span class="c1">#                 return side_1 + side_2</span>
<span class="c1">#             else:</span>
<span class="c1">#                 return wall_info[index_1] + wall_info[index_2]</span>
<span class="c1"># def get_center_point(side_points):</span>
<span class="c1">#     center_point = (reduce(lambda x, y: np.array(x) + np.array(y), side_points)) / float(len(side_points))</span>
<span class="c1">#     min_z = side_points[0][2]</span>
<span class="c1">#</span>
<span class="c1">#     plane_abc = np.cross(np.asarray(side_points[1]) - np.asarray(side_points[0]),</span>
<span class="c1">#                              np.asarray(side_points[2]) - np.asarray(side_points[0]))</span>
<span class="c1">#     plane_d = np.asarray([np.sum(plane_abc * side_points[0]) * -1.0])</span>
<span class="c1">#     a, b, c, d = np.concatenate([plane_abc, plane_d]).tolist()</span>
<span class="c1">#     min_y = (a * center_point[0] + c * min_z + d) / b * (-1.0)</span>
<span class="c1">#     center_xyz = np.asarray([center_point[0], min_y, min_z])</span>
<span class="c1">#</span>
<span class="c1">#     return center_xyz</span>
<span class="c1">#</span>
<span class="c1"># def get_rectangle_points(wall_info):</span>
<span class="c1">#     side_1 = wall_info[0]</span>
<span class="c1">#     side_2 = wall_info[len(wall_info) - 1]</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#     if len(wall_info) == 3:</span>
<span class="c1">#         d_value_1 = np.asarray(side_1[0]) - np.asarray(wall_info[1][0])</span>
<span class="c1">#         # d_1 = math.fabs(d_value_1[0]) + math.fabs(d_value_1[1])</span>
<span class="c1">#         d_1 = math.sqrt(math.pow(d_value_1[0], 2) + math.pow(d_value_1[1], 2))</span>
<span class="c1">#</span>
<span class="c1">#         d_value_2 = np.asarray(side_2[0]) - np.asarray(wall_info[1][0])</span>
<span class="c1">#         # d_2 = math.fabs(d_value_2[0]) + math.fabs(d_value_2[1])</span>
<span class="c1">#         d_2 = math.sqrt(math.pow(d_value_2[0], 2) + math.pow(d_value_2[1], 2))</span>
        
<span class="c1">#         if d_1 &gt; d_2:</span>
<span class="c1">#             return side_1 + wall_info[1]</span>
<span class="c1">#         elif d_1 &lt; d_2:</span>
<span class="c1">#             return side_2 + wall_info[1]</span>
<span class="c1">#         else:</span>
<span class="c1">#             return side_1 + side_2</span>
<span class="c1">#     else:</span>
<span class="c1">#         distance_list = list()</span>
<span class="c1">#         index_list = list()</span>
<span class="c1">#         for value in range(1, len(wall_info) - 1):</span>
<span class="c1">#             d_value = np.asarray(side_1[0]) - np.asarray(wall_info[value][0])</span>
<span class="c1">#             # d = math.fabs(d_value[0]) + math.fabs(d_value[1])</span>
<span class="c1">#             d = math.sqrt(math.pow(d_value[0], 2) + math.pow(d_value[1], 2))</span>
<span class="c1">#             if d_value[2] != 0:</span>
                
<span class="c1">#             distance_list.append(d)</span>
<span class="c1">#             index_list.append(value)</span>
<span class="c1">#</span>
<span class="c1">#         center_point = get_center_point(side_1 + side_2)</span>
<span class="c1">#         center_point -= side_1[0]</span>
<span class="c1">#         # to_center_d1 = math.fabs(center_point[0]) + math.fabs(center_point[1])</span>
<span class="c1">#         to_center_d1 = math.sqrt(math.pow(center_point[0], 2) + math.pow(center_point[1], 2))</span>
<span class="c1">#</span>
<span class="c1">#         max_d = np.amax(np.asarray(distance_list))</span>
<span class="c1">#         min_d = np.amin(np.asarray(distance_list))</span>
<span class="c1">#</span>
<span class="c1">#         min_i = np.argmin(np.asarray(distance_list))</span>
<span class="c1">#         max_i = np.argmax(np.asarray(distance_list))</span>
<span class="c1">#</span>
<span class="c1">#         index_2 = index_list[int(max_i)]</span>
<span class="c1">#         index_1 = index_list[int(min_i)]</span>
<span class="c1">#</span>
<span class="c1">#         if math.fabs(min_d - max_d) &lt;= 0.5:</span>
<span class="c1">#             if index_2 != index_1:</span>
<span class="c1">#                 if max_d &lt; to_center_d1:</span>
<span class="c1">#                     return wall_info[index_1] + side_2</span>
<span class="c1">#                 elif min_d &gt; to_center_d1:</span>
<span class="c1">#                     return wall_info[index_2] + side_1</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     return wall_info[index_1] + wall_info[index_2]</span>
<span class="c1">#             else:</span>
<span class="c1">#                 return side_1 + side_2</span>
<span class="c1">#         else:</span>
<span class="c1">#             return wall_info[index_1] + wall_info[index_2]</span>
<span class="c1">#         # if max_d &lt; to_center_d1:</span>
<span class="c1">#         #     return wall_info[index_1] + side_2</span>
<span class="c1">#         # elif min_d &gt; to_center_d1:</span>
<span class="c1">#         #     return wall_info[index_2] + side_1</span>
<span class="c1">#         # else:</span>
<span class="c1">#         #     if index_1 == index_2:</span>
<span class="c1">#         #         return side_1 + side_2</span>
<span class="c1">#         #     else:</span>
<span class="c1">#         #         return wall_info[index_1] + wall_info[index_2]</span>


<span class="c1"># def get_point_from_line(line_info):</span>
<span class="c1">#</span>
<span class="c1">#     point_set = list()</span>
<span class="c1">#     max_z = line_info[6]</span>
<span class="c1">#     min_z = line_info[7]</span>
<span class="c1">#</span>
<span class="c1">#     temp_surface_info = list()</span>
<span class="c1">#     max_z1 = max_z</span>
<span class="c1">#     max_t = (max_z1 - line_info[5]) / line_info[2]</span>
<span class="c1">#     max_x1 = max_t * line_info[0] + line_info[3]</span>
<span class="c1">#     max_y1 = max_t * line_info[1] + line_info[4]</span>
<span class="c1">#</span>
<span class="c1">#     temp_surface_info.append(float(max_x1))</span>
<span class="c1">#     temp_surface_info.append(float(max_y1))</span>
<span class="c1">#     temp_surface_info.append(float(max_z1))</span>
<span class="c1">#     point_set.append(temp_surface_info)</span>
<span class="c1">#     temp_surface_info = list()</span>
<span class="c1">#     min_z1 = min_z</span>
<span class="c1">#     min_t = (min_z1 - line_info[5]) / line_info[2]</span>
<span class="c1">#     min_x1 = min_t * line_info[0] + line_info[3]</span>
<span class="c1">#     min_y1 = min_t * line_info[1] + line_info[4]</span>
<span class="c1">#</span>
<span class="c1">#     temp_surface_info.append(float(min_x1))</span>
<span class="c1">#     temp_surface_info.append(float(min_y1))</span>
<span class="c1">#     temp_surface_info.append(float(min_z1))</span>
<span class="c1">#     point_set.append(temp_surface_info)</span>
<span class="c1">#</span>
<span class="c1">#     return point_set</span>




<span class="c1"># if __name__ == &quot;__main__&quot;:</span>
<span class="c1">#</span>
<span class="c1">#     start_vect = time.time()</span>
<span class="c1">#     # cloud = pcl.load(&quot;/home/dprt/Desktop/Untitled Folder 3/Untitled Folder 3/Untitled Folder 2/cloud_cluster_9459.pcd&quot;)</span>
<span class="c1">#     # cloud = pcl.load(&quot;/home/dprt/Desktop/Demo/IOU_test/Test_part_area_wall.ply&quot;)</span>
<span class="c1">#     # cloud = pcl.load(&quot;/home/dprt/Desktop/SC_DEMO/New Folder/SC/20.ply&quot;)</span>
<span class="c1">#     path = &quot;/home/dprt/Desktop/Sigspatial_LBJ/booth1.ply&quot;</span>
<span class="c1">#     file_name = (path.split(&#39;/&#39;)[-1]).split(&#39;.&#39;)[0]</span>
<span class="c1">#     cloud = pcl.load(&quot;/home/dprt/Desktop/pinsout_gitlab/pinsout/data/Sigspatial_LBJ/booth7.ply&quot;)</span>
<span class="c1">#     # cloud = pcl.load(&quot;/home/dprt/Desktop/lbj/merge2.ply&quot;)</span>
<span class="c1">#     # cloud = pcl.load(&quot;/home/dprt/Desktop/lbj/npy_data2/dump/merge_subsample_nofloor_wall (copy).ply&quot;)</span>
<span class="c1">#     # cloud = pcl.load(&quot;/home/dprt/Desktop/21/Untitled Folder 2/colorizedlast_wall2.ply&quot;)</span>
<span class="c1">#     # cloud = pcl.load(&quot;/home/dprt/Desktop/Demo/test/sc_test_data_Booth_10_ceiling.ply&quot;)</span>
<span class="c1">#</span>
<span class="c1">#     # cloud = pcl.load(&quot;/home/dprt/Desktop/Demo/IOU_test/Untitled Folder/colorized_wall.ply&quot;)</span>
<span class="c1">#     # a = clustering(cloud)</span>
<span class="c1">#</span>
<span class="c1">#     a = make_wall_info(cloud)</span>
<span class="c1">#     first_process_runtime = (time.time() - start_vect) / 60</span>
<span class="c1">#</span>
<span class="c1">#     poly2obj = po.Ply2Obj(a)</span>
<span class="c1">#     poly2obj.poly_2_obj(&#39;All&#39;)</span>
<span class="c1">#</span>
<span class="c1">#     # dae_filename = &#39;/home/dprt/Desktop/pinsout_gitlab/pinsout/data/sc_demo/&#39;+file_name+&#39;.dae&#39;</span>
<span class="c1">#</span>
<span class="c1">#     dae_filename = &#39;/home/dprt/Desktop/pinsout_gitlab/pinsout/data/sc_demo/booth7.dae&#39;</span>
<span class="c1">#     poly2obj.output_dae(dae_filename)</span>

<span class="c1"># /usr/local/cuda/lib64:$LD_LIBRARY_PATH</span>







</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Wijae Cho

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>